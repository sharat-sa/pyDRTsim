import numpy as np
import scipy.sparse as sps
from scipy.sparse.linalg import spsolve
from scipy.spatial import Voronoi, cKDTree
import time
import sys

class SyntheticMicrostructure:
    """
    Generates a 3D procedural microstructure, including a voxelized
    Voronoi grain map and a 2D porous interface map.
    This class replaces the need for an SEM image input.
    """
    def __init__(self, grid_dims, num_grains):
        self.grid_dims = np.array(grid_dims)
        self.num_grains = num_grains
        self.num_voxels = np.prod(self.grid_dims)
        
        print(f"Generating {self.grid_dims} microstructure with {num_grains} grains...")
        
        # 1. Generate 3D Voronoi grain map
        self.grain_map = self._generate_voxelized_voronoi()
        
        # 2. Placeholder for 2D interface map (will be generated by the model)
        self.interface_map = np.ones(self.grid_dims[1:], dtype=int)
        print("Microstructure generation complete.")

    def _generate_voxelized_voronoi(self):
        """
        Creates a 3D numpy array where each element's value is the
        ID of the closest Voronoi seed, representing a grain.
        """
        # Create random seed points for Voronoi cells (grains)
        seeds = np.random.rand(self.num_grains, 3) * self.grid_dims
        
        # Create a grid of voxel center coordinates
        z, y, x = np.indices(self.grid_dims)
        voxel_coords = np.stack((z, y, x), axis=-1).reshape(-1, 3)
        
        # Use cKDTree for efficient nearest-neighbor search
        # This is the voxelization step
        print("Voxelizing Voronoi diagram (nearest-neighbor search)...")
        tree = cKDTree(seeds)
        distances, indices = tree.query(voxel_coords, k=1)
        
        # Reshape the 1D index array back into the 3D grid shape
        return indices.reshape(self.grid_dims)

    def generate_porous_interface(self, contact_ratio):
        """
        Generates a 2D map of 'pores' (0) and 'contact spots' (1)
        at the z=0 plane.
        
        Args:
            contact_ratio (float): The fractional contact area (0.0 to 1.0).
        """
        if contact_ratio == 1.0:
            self.interface_map = np.ones((self.grid_dims[0], self.grid_dims[1]), dtype=int)
        else:
            # Create a simple random distribution of pores
            self.interface_map = (np.random.rand(self.grid_dims[0], self.grid_dims[1]) < contact_ratio).astype(int)
        print(f"Generated interface with {np.mean(self.interface_map)*100:.2f}% contact area.")

    def get_voxel_id(self, z, y, x):
        """Convert 3D index to 1D node index."""
        if 0 <= z < self.grid_dims[2] and \
           0 <= y < self.grid_dims[1] and \
           0 <= x < self.grid_dims[0]:
            return x + (y * self.grid_dims[0]) + (z * self.grid_dims[0] * self.grid_dims[1])
        return None

    def get_grain_id(self, k):
        """Get grain ID from a 1D node index."""
        z = k // (self.grid_dims * self.grid_dims)
        y = (k % (self.grid_dims * self.grid_dims)) // self.grid_dims
        x = k % self.grid_dims
        return self.grain_map[z, y, x]
    
    def get_interface_type(self, k):
        """Get interface type (pore/contact) from a 1D node index at z=0."""
        if k >= (self.grid_dims * self.grid_dims):
            raise ValueError("Node is not at the z=0 interface.")
        y = k // self.grid_dims
        x = k % self.grid_dims
        return self.interface_map[y, x]


class ImpedanceNetworkModel:
    """
    Implements the unified Nodal Analysis model for a given
    SyntheticMicrostructure and set of physical parameters.
    """
    def __init__(self, microstructure, params):
        self.m = microstructure
        self.p = params
        self.num_voxels = self.m.num_voxels
        
        self.top_nodes = np.arange(self.m.grid_dims[0] * self.m.grid_dims[1])
        self.bottom_nodes = np.arange(self.num_voxels - self.m.grid_dims[0] * self.m.grid_dims[1], self.num_voxels)

        self._calculate_element_properties()

    def _calculate_element_properties(self):
        """
        Pre-calculates the R and C values for the fundamental
        RC elements based on user parameters.
        """
        d = self.p['voxel_size']
        A = d**2
        
        # Bulk element (half-voxel)
        self.R_bulk_half = (d/2) / (self.p['sigma_bulk'] * A)
        self.C_bulk_half = (self.p['epsilon_bulk'] * A) / (d/2)
        
        # Grain Boundary element
        self.R_gb = self.p['delta_gb'] / (self.p['sigma_gb'] * A)
        self.C_gb = (self.p['epsilon_gb'] * A) / self.p['delta_gb']
        
        # Charge Transfer element
        self.R_ct = self.p['delta_ct'] / (self.p['sigma_ct'] * A)
        self.C_ct = (self.p['epsilon_ct'] * A) / self.p['delta_ct']
        
        # Pore element (purely capacitive)
        self.C_pore = (self.p['epsilon_pore'] * A) / self.p['delta_pore']
        
        # Pore half element (for lateral pore-pore/pore-bulk)
        self.C_pore_half = (self.p['epsilon_pore'] * (d * self.p['delta_pore'])) / (d/2)


    def _get_local_admittance(self, k_idx, j_idx, omega):
        """
        THE UNIFIED HYBRID MODEL KERNEL.
        Calculates the complex admittance y_kj = 1/Z_kj between
        two adjacent nodes based on the rules in Section 3.3.
        """
        
        # Function to calculate admittance of a parallel RC element
        def y_rc(R, C, w):
            if np.isinf(R): # Pure capacitor (like a pore)
                return 1j * w * C
            return (1.0 / R) + (1j * w * C)
            
        # Get 3D coordinates
        k_z = k_idx // (self.m.grid_dims[0] * self.m.grid_dims[1])
        k_y = (k_idx % (self.m.grid_dims[0] * self.m.grid_dims[1])) // self.m.grid_dims[0]
        k_x = k_idx % self.m.grid_dims[0]
        
        j_z = j_idx // (self.m.grid_dims[0] * self.m.grid_dims[1])
        j_y = (j_idx % (self.m.grid_dims[0] * self.m.grid_dims[1])) // self.m.grid_dims[0]
        j_x = j_idx % self.m.grid_dims[0]
        
        # Get grain IDs
        grain_k = self.m.grain_map[k_z, k_y, k_x]
        grain_j = self.m.grain_map[j_z, j_y, j_x]
        
        # === CASE 1: BULK-TO-BULK (z > 0) ===
        # (We assume z-axis connection, but logic applies to x,y too)
        # For simplicity, we'll only model z=0 interface physics.
        # All other connections are bulk.
        
        is_interface_connection = (k_z == 0 and j_z == 0)
        
        if not is_interface_connection:
            # Standard Bulk/GB physics (Eckhardt 2021)
            y_bulk_half = y_rc(self.R_bulk_half, self.C_bulk_half, omega)
            
            if grain_k == grain_j:
                # Intra-grain: Z_bulk_half + Z_bulk_half
                Z_kj = 2.0 / y_bulk_half
            else:
                # Inter-grain: Z_bulk_half + Z_gb + Z_bulk_half
                y_gb = y_rc(self.R_gb, self.C_gb, omega)
                Z_kj = (2.0 / y_bulk_half) + (1.0 / y_gb)
            
            return 1.0 / Z_kj

        # === CASE 3: LATERAL AT INTERFACE (z=0) ===
        else:
            type_k = self.m.interface_map[k_y, k_x]
            type_j = self.m.interface_map[j_y, j_x]
            
            y_bulk_half = y_rc(self.R_bulk_half, self.C_bulk_half, omega)
            y_pore_half = y_rc(np.inf, self.C_pore_half, omega)
            
            # Contact (1) to Contact (1)
            if type_k == 1 and type_j == 1:
                if grain_k == grain_j:
                    Z_kj = 2.0 / y_bulk_half
                else:
                    y_gb = y_rc(self.R_gb, self.C_gb, omega)
                    Z_kj = (2.0 / y_bulk_half) + (1.0 / y_gb)
            
            # Contact (1) to Pore (0)
            elif type_k!= type_j:
                Z_kj = (1.0 / y_bulk_half) + (1.0 / y_pore_half)
            
            # Pore (0) to Pore (0)
            else:
                Z_kj = 2.0 / y_pore_half
                
            return 1.0 / Z_kj


    def build_admittance_matrix(self, omega):
        """
        Builds the sparse N_voxel x N_voxel admittance matrix Y
        for a given angular frequency omega.
        (Source: Eckhardt 2021, Supp. Info, Eq. SE4)
        """
        data = []
        rows = []
        cols = []
        
        # Function to calculate admittance of a parallel RC element
        def y_rc(R, C, w):
            if np.isinf(R): # Pure capacitor (like a pore)
                return 1j * w * C
            return (1.0 / R) + (1j * w * C)
        
        # Iterate over all voxels (nodes)
        for k_idx in range(self.num_voxels):
            # Get 3D coords for neighbor finding
            k_z = k_idx // (self.m.grid_dims[0] * self.m.grid_dims[1])
            k_y = (k_idx % (self.m.grid_dims[0] * self.m.grid_dims[1])) // self.m.grid_dims[0]
            k_x = k_idx % self.m.grid_dims[0]
            
            Y_kk_diag = 0 + 0j # Diagonal element Y_kk = sum(y_kj)
            
            # Iterate over 6 neighbors (x, y, z directions)
            for dz, dy, dx in [(0, 0, 1), (0, 0, -1),
                               (0, 1, 0), (0, -1, 0),
                               (1, 0, 0), (-1, 0, 0)]:
                
                j_z, j_y, j_x = k_z + dz, k_y + dy, k_x + dx
                
                # Check if neighbor is inside the grid
                if 0 <= j_z < self.m.grid_dims[2] and \
                   0 <= j_y < self.m.grid_dims[1] and \
                   0 <= j_x < self.m.grid_dims[0]:
                    
                    j_idx = self.m.get_voxel_id(j_z, j_y, j_x)
                    
                    # === Apply Hybrid Model ===
                    if k_z > 0 or j_z > 0:
                        # Case 1: Standard Bulk/GB connection
                        y_kj = self._get_local_admittance(k_idx, j_idx, omega)
                    
                    else:
                        # Case 3: Lateral interface connection
                        y_kj = self._get_local_admittance(k_idx, j_idx, omega)
                        
                    # Add to sparse matrix lists
                    if k_idx!= j_idx:
                        data.append(-y_kj) # Off-diagonal Y_kj = -y_kj
                        rows.append(k_idx)
                        cols.append(j_idx)
                    
                    Y_kk_diag += y_kj
            
            # === Handle Electrode Connections ===
            
            # --- Top Electrode (z=0) ---
            if k_z == 0:
                y_electrode_contact = 0 + 0j
                node_type = self.m.interface_map[k_y, k_x]
                
                # Case 2: Electrode-to-Bulk connection
                if node_type == 1: # Contact Spot
                    y_ct = y_rc(self.R_ct, self.C_ct, omega)
                    y_bulk_half = y_rc(self.R_bulk_half, self.C_bulk_half, omega)
                    Z_kj = (1.0 / y_ct) + (1.0 / y_bulk_half)
                    y_electrode_contact = 1.0 / Z_kj
                else: # Pore
                    y_pore = y_rc(np.inf, self.C_pore, omega)
                    y_bulk_half = y_rc(self.R_bulk_half, self.C_bulk_half, omega)
                    Z_kj = (1.0 / y_pore) + (1.0 / y_bulk_half)
                    y_electrode_contact = 1.0 / Z_kj
                
                Y_kk_diag += y_electrode_contact

            # --- Bottom Electrode (z=L) ---
            if k_z == self.m.grid_dims[2] - 1:
                # Connect to ground (phi=0)
                # This is a "contact spot" with no GB/Constriction
                y_bulk_half = y_rc(self.R_bulk_half, self.C_bulk_half, omega)
                Y_kk_diag += y_bulk_half # Add connection to ground

            # Add the final diagonal element
            data.append(Y_kk_diag)
            rows.append(k_idx)
            cols.append(k_idx)
            
        # Build the final sparse matrix
        return sps.coo_matrix((data, (rows, cols)), shape=(self.num_voxels, self.num_voxels), dtype=complex).tocsr()

    def _build_current_vector(self, i_total=1.0):
        """
        Builds the external current vector 'i'.
        Current is injected at top (z=0) and ground is at z=L.
        """
        i_vector = np.zeros(self.num_voxels, dtype=complex)
        
        # Inject current at top nodes (z=0)
        num_top_nodes = self.m.grid_dims[0] * self.m.grid_dims[1]
        i_per_node = i_total / num_top_nodes
        i_vector[self.top_nodes] = i_per_node
        
        return i_vector

    def run_simulation(self, frequencies):
        """
        Runs the full impedance simulation over a range of frequencies.
        """
        Z_spectrum = []
        i_vector = self._build_current_vector(i_total=1.0)
        
        # We solve for a reduced system. Nodes at the bottom are
        # set to phi=0 (ground) and removed from the matrix.
        
        # Get all nodes *except* the bottom layer
        active_nodes = np.arange(self.num_voxels - len(self.bottom_nodes))
        
        for freq in frequencies:
            start_time = time.time()
            omega = 2 * np.pi * freq
            
            # 1. Build the full Y matrix
            Y_full = self.build_admittance_matrix(omega)
            
            # 2. Extract the sub-matrix for active (non-ground) nodes
            Y_active = Y_full[active_nodes, :][:, active_nodes]
            
            # 3. Get the current vector for active nodes
            i_active = i_vector[active_nodes]
            
            # 4. Solve the linear system Y*phi = i
            try:
                phi_active = spsolve(Y_active, i_active)
            except Exception as e:
                print(f"Solver failed at f={freq} Hz. Error: {e}")
                Z_spectrum.append(np.nan)
                continue
            
            # 5. Calculate total Z.
            # Z_total = phi_top_avg / i_total
            # Since i_total = 1.0, Z_total = phi_top_avg
            phi_top_nodes = phi_active[self.top_nodes]
            Z_total = np.mean(phi_top_nodes)
            
            Z_spectrum.append(Z_total)
            print(f"f = {freq:.2e} Hz | Z = {Z_total.real:.2e} - j{abs(Z_total.imag):.2e} Ohm | Time = {time.time()-start_time:.2f}s")
            
        return np.array(Z_spectrum)


# ===================================================================
# === MAIN EXECUTION SCRIPT ===
# ===================================================================

def run_full_simulation():
    """
    Main function to define parameters, run the model,
    and plot the results.
    """
    
    # --- 1. DEFINE USER-INPUT PARAMETERS ---
    # (as requested in the query)
    
    # Table 1: Unified Model Input Parameters
    parameters = {
        # Grid & Microstructure
        "grid_dims": (10, 10, 10),      # (z, y, x) voxels. Keep small (e.g., 10^3) for quick test. 
                                        # A 50^3 grid (125k nodes) is a large computation.
        "voxel_size": 100e-9,           # (m) 100 nm voxels
        "num_grains": 50,               # Number of Voronoi seeds
        "contact_ratio": 0.5,           # Fractional contact area (1.0 = ideal, 0.5 = 50% pores)
        
        # Bulk Properties (Based on typical ceramic)
        "sigma_bulk": 1.4e-3,             # (S/m)
        "epsilon_bulk": 150 * 8.854e-12, # (F/m) (epsilon_r = 100)
        
        # Grain Boundary Properties (Highly resistive)
        "sigma_gb": 1e-5,               # (S/m) (3 orders of magnitude lower than bulk)
        "epsilon_gb": 80 * 8.854e-12,   # (F/m)
        "delta_gb": 10e-9,              # (m) Effective thickness
        
        # Interface Properties (Constriction & CT)
        "epsilon_pore": 6 * 8.854e-12,   # (F/m) (Permittivity of vacuum)
        "delta_pore": 50e-9,            # (m) Depth of the porous interface layer
        "sigma_ct": 0.1,                # (S/m) (High conductivity for charge transfer)
        "epsilon_ct": 100 * 8.854e-12,   # (F/m)
        "delta_ct": 5e-9                # (m) Effective thickness of CT layer
    }
    
    # --- 2. SETUP MICROSTRUCTURE ---
    micro = SyntheticMicrostructure(parameters['grid_dims'], parameters['num_grains'])
    micro.generate_porous_interface(parameters['contact_ratio'])
    
    # --- 3. SETUP AND RUN MODEL ---
    model = ImpedanceNetworkModel(micro, parameters)
    
    # Define frequency range
    frequencies = np.logspace(-2, 11, 100) # 0.01 Hz to 10 MHz
    
    print("\nStarting Unified Impedance Simulation...")
    Z_spectrum = model.run_simulation(frequencies)
    
    # --- 4. PLOT RESULTS ---
    try:
        import matplotlib.pyplot as plt
        
        # Clean up any solver failures
        valid = ~np.isnan(Z_spectrum)
        if not np.any(valid):
            print("Simulation failed for all frequencies.")
            return

        Z_spectrum = Z_spectrum[valid]
        frequencies = frequencies[valid]

        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 6))
        
        # Nyquist Plot
        ax1.plot(Z_spectrum.real, -Z_spectrum.imag, 'o-', mfc='r', mec='k')
        ax1.set_xlabel("Z' (Ohm)")
        ax1.set_ylabel("-Z'' (Ohm)")
        ax1.set_title("Nyquist Plot")
        ax1.grid(True)
        ax1.axis('equal')
        
        # Bode Plot
        ax2.loglog(frequencies, np.abs(Z_spectrum), 'o-', label='|Z|')
        ax2.loglog(frequencies, -Z_spectrum.imag, 's--', label="-Z''", mfc='none')
        ax2.set_xlabel("Frequency (Hz)")
        ax2.set_ylabel("Impedance (Ohm)")
        ax2.set_title("Bode Plot")
        ax2.grid(True)
        ax2.legend()
        
        # DRT Plot
        try:
            sys.path.append('pyDRTtools-master')
            from pyDRTtools.runs import EIS_object, simple_run
            
            eis = EIS_object(frequencies, Z_spectrum.real, Z_spectrum.imag)
            simple_run(eis, cv_type='custom', reg_param=1e-4)
            
            ax3.plot(eis.out_tau_vec, eis.gamma, 'b-')
            ax3.set_xlabel("Time Constant (s)")
            ax3.set_ylabel("DRT")
            ax3.set_title("Distribution of Relaxation Times")
            ax3.grid(True)
            ax3.set_xscale('log')
        except ImportError:
            ax3.text(0.5, 0.5, 'pyDRTtools not available', transform=ax3.transAxes, ha='center')
            ax3.set_title("DRT Plot (Unavailable)")
        
        plt.suptitle("Unified 3D Impedance Simulation (Polycrystalline + Constriction)")
        plt.tight_layout()
        plt.show()

    except ImportError:
        print("\nMatplotlib not found. Plotting skipped.")
        print("Simulation complete. Z_spectrum:")
        print(Z_spectrum)

# Uncomment the line below to run the simulation
run_full_simulation()

print("Unified 3D Impedance Model code is defined.")
print("To run, save this script and call 'run_full_simulation()'.")